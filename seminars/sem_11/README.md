# Графи
## Днес ще разгледаме
* Представяне на граф
* Обхождане в ширина на граф (BFS)
* Обхождане в дълбочина на граф (DFS)
* Топологична сортировка (Topological sorting)
* Съвети за решаване на задачи с граф

## Граф
Графът е нелинейна структура от данни, която представлява връзките между отделните елементи на дадено множество. Всеки член на това множество се нарича връх (V), а връзката между два върха се нарича ребро (E).

### Ориентиран граф (Directed graph)
* Всяко ребро има посока.
* Ако съществува ребро от връх А до връх В, то позволява преминаването само от А към Б.

### Неориентиран граф (Undirected graph)
* Ребрата нямат посока.
* Ако съществува ребро между връх А и връх Б, то позволява преминаването от А към Б и от Б към А.

### Претеглен граф
Граф, чиито ребра имат стойности. Стойностите се интерпретират като тегло, цена, разстояние и т.н. за преместването от един връх до друг по съответното ребро.

### Още термини и свойста
* Цикъл - в един граф има цикъл, когато имаме път, който има дължина поне 2 и започва и свършва с един и същ връх.
* Ацикличен граф - граф без цикли.
* Степен (Degree) - брой ребра входящи/изходящи за даден връх.
  * indegree - брой входящи ребра
  * outdegree - брой изходящи ребра
* Sparse граф - граф с ниска средна стойност на степен на върховете.
* Dense граф - граф с висока средна стойност на степен на върховете.
* Свързаност
  * свързан граф - между всеки два върха в графа имаме път.
  * несвързан граф - има поне два върха между които няма път (т.е. имаме няколко компоненти на свързаност в графа).
* DAG - directed acyclic graph

### Разлики с дърво
* В граф може да има цикли.
* Един граф не е задължително да е свързан (т.е. между всеки два върха да има път).
* Дърветата имат йерархична подредба.

## Представяне на граф
### Матрица на съседство (Adjacency matrix)
* Връзките между върховете се представят чрез булева матрица (А).
* Ако съществува ребро от връх Vi до Vj, клетката Аij = 1.
* Матрицата е симетрична при ненасочен граф.
* Изисква V2 допълнителна памет.
* Позволява константа проверка дали има ребро между два върха.
* Подходящо представяне за dense графи.
* Пример:
```
graph = [
    [0, 1, 1, 1],
    [1, 0, 1, 0],
    [1, 1, 0, 0],
    [1, 0, 0 ,0]
];
```
```
vector<vector<int>> graph = {
    {0, 1, 1, 1},
    {1, 0, 1, 0},
    {1, 1, 0, 0},
    {1, 0, 0, 0}
};
```
### Списък на съседство (Adjacency list)
* Всеки връх съдържа списък с върховете, до които има непосредствени ребра (съседите).
* Ако съществува ребро от връх Vi до Vj, списъкът на съседство на Vi ще съдържа връх Vj.
* Изисква V + Е допълнителна памет.
* Не предоставя константа проверка дали има ребро между два върха (*имплементацията със списък от сетове позволява).
* Подходящо представяне за sparse графи.
* При dense графи, когато E клони към V2, по-подходящо ще е представяне чрез матрица на съседство.
```
graph = {
    '0': set([1, 2, 3]),
    '1': set([0, 2]),
    '2': set([0, 1]),
    '3': set([0])
};
```
```
unordered_map<int, unordered_set<int>> graph = {
    {0, {1, 2, 3}},
    {1, {0, 2}},
    {2, {0, 1}},
    {3, {0}}
};
```
### Списък на ребрата
* Представяме графа като списък от наредени двойки.
* Често се използва като input за построяване на графа.
* Не е полезен в повечето задачи.
```
graph = [
    (0, 1),
    (0, 2),
    (0, 3),
    (1, 2),
];
```
```
std::vector<std::pair<int, int>> graph = {
    {0, 1},
    {0, 2},
    {0, 3},
    {1, 2},
    {2, 3}
};
```

## Обхождания
Note: BFS и DFS на граф надграждат съответните имплементации за дървета, разгледани в тема 7.

### Breadth First Search

Алгоритъм:
1. Разделя възлите на посетени и непосетени.
2. Започва да обхожда от подаден начален връх.
3. Добавя всички съседи, които не са посетени, към края на опашка от върхове за следващо обхождане.
4. Взима първия елемент от опашката и повтаря стъпка 3, докато има елементи в опашката.

Свойства:
* Намира най-къс път от даден възел до всички останали в непретеглен граф (всички ребра са с еднаква дължина/ тежест).
* Стои в основата на по-сложни алгоритми като Алгоритъм на Дийкстра.
* O(V + E) сложност по време.

Code:
```
void bfs(int starting_vertex, unordered_map<int, unordered_set<int>>& graph) {
    queue<int> q;
    unordered_set<int> visited;
    q.push(starting_vertex);
    visited.insert(starting_vertex);

    int distance = 0;

    while (!q.empty()) {
        int level_size = q.size();
        cout << "At distance " << distance << ":\n";

        for (int i = 0; i < level_size; ++i) {
            int current = q.front();
            q.pop();
            cout << current << "\n";

            for (int neighbor : graph[current]) {
                if (!visited.count(neighbor)) {
                    visited.insert(neighbor);
                    q.push(neighbor);
                }
            }
        }
        distance++;
    }
}
```

### Depth First Search

Алгоритъм:
1. Разделя възлите на посетени и непосетени.
2. Започва да обхожда от подаден начален връх.
3. Добавя всички съседи, които не са посетени, към края на стек* от върхове за следващо обхождане.
4. Взима първия елемент от стека и повтаря стъпка 3, докато има елементи в стека.

Свойства:
* Удобен за намиране на компоненти на свързаност, проверка за цикъл в граф и топологична сортировка. (*Забележка: Възможно е и използването на BFS за решаване на горните проблеми.)
* O(V + E) сложност по време.

Code:
```
void dfs(int current, unordered_set<int> &visited, unordered_map<int, unordered_set<int>> &graph) {
    cout << current << " "; // 0 3 5 6 4 1 2
    visited.insert(current);

    for (int neighbor : graph[current]) {
        if (!visited.count(neighbor)) {
            dfs(neighbor, visited, graph);
        }
    }
}
```

### Топологична сортировка
* Подрежда върховете, така че всеки възел се намира преди наследниците си, към които има ребра.
* Работи за DAG (Directed Acyclic Graph).

Code:
```
void topological_dfs(int current, unordered_set<int> &visited, vector<int> &stack, unordered_map<int, unordered_set<int>> &graph) {
    visited.insert(current);

    for (int neighbor : graph[current]) {
        if (!visited.count(neighbor)) {
            topological_dfs(neighbor, visited, stack, graph);
        }
    }
    stack.push_back(current);
}

vector<int> topological_sort(unordered_map<int, unordered_set<int>> &graph) {
    vector<int> stack;
    unordered_set<int> visited;

    for (auto iter = graph.begin(); iter != graph.end(); ++iter) {
        int vertex = iter->first;
        if (!visited.count(vertex)) {
            topological_dfs(vertex, visited, stack, graph);
        }
    }

    std::reverse(stack.begin(), stack.end());

    return stack; // 1 4 2 3 5 6
}
```
