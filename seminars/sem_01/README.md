# Сложност на алгоритми.
### Алгоритъм
Алгоритъм ще наричаме последователност от стъпки за решаването на даден проблем.

### Структура от данни
Структура от данни ще наричаме начин за организирането на данните в удобен за употреба формат.

### Сложност
Сложността на алгоритмите е ключов аспект в компютърните науки, който определя ефективността на алгоритъма по отношение на времето и паметта, които използва. Определянето на сложността помага при избора на най-добрия алгоритъм за дадена задача, като се има предвид времевите ограничения и наличните ресурси. Основните видове сложност са сложност по време и сложност по памет.

#### Сложност по време
Сложността по време се определя от броя стъпки, необходими за изпълнението на алгоритъма. Тя описва как броят на стъпките нараства с увеличаване на размера на входните данни. При анализа на времевата сложност на алгоритмите е важно да се разглеждат различни сценарии, които могат да се случат по време на изпълнението на алгоритъма. Най-често използваните типове времева сложност са:
* Best-Case
* Worst-Case
* Average-Case
* Амортизирана сложност

##### Примери за времева сложност в контекста на броя стъпки

O(1) - константна сложност
````
void printElement(const int* arr, size_t index) {
    std::cout << arr[index] << std::endl; 
}
````

O(n) - линейна сложност
```
void printAllElements(const int* arr, size_t size) {
    for (int i = 0; i < size; i++) { 
        std::cout << arr[i] << std::endl;
    }
}
```

O(log n) - логаритмична сложност
```
int binarySearch(const int* arr, size_t size, int target) {
    int left = 0;
    int right = size - 1;
    while (left <= right) {   
        int mid = left + (right - left) / 2;

        if (arr[mid] == target) {
            return mid;
        }
        else if (arr[mid] < target) {
            left = mid + 1;
        }
        else {
            right = mid - 1;
        }
    }
    return -1;
}
```

O(n*log n) - линейно-логаритмична сложност
```
void printIndexes(const int* arr, size_t size) {
    for (int i = 0; i < size; i++) {   // n стъпки
        std::cout << binarySearch(arr, size, arr[i]) << std::endl; 
    }
}
```

O(n^2) - квадратична сложност
```
void printAllPairs(const int* arr, size_t size) {
    for (int i = 0; i < size; i++) {       
        for (int j = 0; j < size; j++) {   
            std::cout << arr[i] << " " << arr[j] << std::endl;  
        }
    }
}
```
#### Сложност по Памет
Сложността по памет измерва количеството памет, необходимо за изпълнението на алгоритъма в зависимост от размера на входните данни.

##### Примери
O(1) - Константна сложност по памет - алгоритъмът използва фиксирано количество памет, независимо от размера на входа.
```
int sumArray(const int* arr, size_t size) {
    int sum = 0;
    for (int i = 0; i < size; i++) {
        sum += arr[i];
    }
    return sum;
}
```
O(n) - Линейна сложност по памет - паметта, необходима за алгоритъма, нараства линейно с размера на входа.
```
int* createArray(int size) {
    int* arr = new int[size];
    for (int i = 0; i < size; i++) {
        std::cin >>arr[i];
    }
    return arr;
}
```

# Необходими структури от данни:
* std::string
* std::pair
* std::vector
