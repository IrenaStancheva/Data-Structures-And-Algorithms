# Дек, стек и опашка.

## std::stack
Стекът представлява колекция от данни, която поддържа 3 главни операции:

* push(el)
* pop()
* peek() -> .top()

Важно е, че не поддържа iterator pattern и пряка индексация.

Стекът работи на принципа LIFO - last in first out. Това идва именно от поддържаните операции. Операцията push добавя елемент към колекцията. Операцията pop премахва последно добавения елемент от колекцията.

Има и метод, който достъпва "най-горния" елемент. И именно около него се "върти" концепцията на стека - само до него имаме достъп и само него ще можем да модифицираме - да достъпваме, променяме или премахваме.


## std::queue

* push(el)
* pop()
* peek() -> .front(), .back()

Важно е, че отново не поддържа iterator pattern и пряка индексация.

Тази структура работи на принципа FIFO - first in first out. За да обясним работата на опашката, ще разгледаме следния пример: Представете си, че сте лекарф в кабинет. Пред кабинета има опашка от пациенти, като вие започвате да приемате пациентите по ред на идване - първия дошъл, втория и т.н. Вас ви интересува само кой е дошъл най-рано и съответно че неговият ред е дошъл. Пациентите обаче ги интересува и последния на опашката - за да знаят след кого им идва реда. Те образуват една "опашка", подобна на stl-ската. Вие като доктор pop-вате пациенти от началото на опашката, а новодошлите се push-ват в края й. С това се обобщават и методите на опашката, които са написани по-горе.

## std::deque
Срещат се различни имплементации на дека, като например:
* circular buffer
* doubly linked list
* segment array.

Ние ще разгледаме последната имплементация, коато всъщност е и стандартната имплементация, а именно - на сегментен масив. Понятието "сегментен масив" може би звучи сложно първоначално, но сами ще се убедите, че няма нищо сложно в него. Данните ни се съхраняват в "блокчета" памет с константна големина. Тоест, за да ги съхраним, ни трябва масивче от указатели към такива блокчета памет. Ще пазим индекс на първия елемент (offset) и размера на колекцията (size), за да намерим последния (offset + size). Идеята му е, че започваме да добавяме елементи от средата на нашия "map" от блокчета по 2 начина:
* в началото, като там местим offset назад и увеличаваме сайза;
* в края, като просто увеличаваме сайза;

При resize на масивчето от блокчета просто се копират указателите, което прави resize-овете доста по-cheap отколкото при вектора. Стария "map" се поставя в средата на новия, за да имаме място отгоре за push_front() и отдолу за push_back().

Друго важно нещо е, че тук имаме пряка индексация на елементите чрез operator[]. Имаме и итератор патърн.
