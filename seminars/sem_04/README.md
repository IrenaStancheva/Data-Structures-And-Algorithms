# Алгоритми за търсене.
## Линейно търсене
Обхождаме цялата колекция и да проверяваме дали даден елемент е в нея. 
Съответно, ако го намерим, искаме да върнем позицията му. 
Цялата тази идея е имплементирана в алгоритъма Linear Search. Примерна имплементация:
```
template <class T> 
int linear_search(const std::vector<T>& data, const T& el)
{
    for (int i = 0; i < data.size(); i++)
    {
        if (data[i] == el)
            return i;
    }

    return -1;
}
```
* Сложността му в worst-case е O(n).
* В average-case O(n). 
* best-case O(1).


Оптимизиране на лагоритъма чрез добавяне на sentinel в края на колекцията:
```
template <class T> 
int linear_search_sentinel(const std::vector<T>& data, const T& el)
{
    T last = data.back();
    data.back() = el;

    int i = 0;
    while (el != data[i])
    {
        i++;
    }
    
    data.back() = last;

    if(i < data.size() - 1 || data.back() == el)
        return i;

    return -1;
}
```
## Binary Search
Работи само при предварително сортирани данни!
Идеята му е да вземем средния елемент на колекцията. 
Той я разделя на две половини - лява и дясна.
Първо ще сравним търсения със средния елемент - ако са равни, 
значи сме го открили и можем да върнем неговата позиция. 
Ако не са равни, ще направим следното: тъй като колекцията ни е сортирана, 
ако търсеният елемент е по-голям от средния, значи се намира в дясната половина,
а ако е по-малък - съответно в лявата.
По този начин ще приложим същото търсене върху половината, 
в която вече сме сигурни, че се намира нашия елемент и така, 
докато не стигнем до него.
```
template <class T>
int binary_search(const std::vector<T>& data, T el)
{
    int beg = 0, end = data.size() - 1;

    while (beg <= end)
    {
        int mid = beg + (end - beg) / 2;

        if (data[mid] == el)
            return mid;

        if (el < data[mid])
            end = mid - 1;
        else
            beg = mid + 1;
    }

    return -1;
}
```

* Алгоритъмът има сложност O(logn) в worst-case.
* В average-case  Съответно намираме сложността чрез уравнението: Θ(logn).
* Best-case ще имаме (O(1)).

## Стандартни алгоритми за търсене - std::find, std::find_if и std::find_if_not

## std::upper_bound и std::lower_bound
* std::upper_bound и std::lower_bound отново са методи от стандартната библиотека, 
базирани на алгоритми за търсене. Особеното тук е, че са базирани на двоичното търсене,
т.е. задължават колекцията ни да е сортирана предварително, за да ги използваме. 
Сложността им е съответно O(logn).

* std::upper_bound приема итератори към началото и края на range-a, в който ще търси,
както и елемент. Връща итератор към първия елемент от колекцията,
който е по-голям от подадения. Ако няма такъв, връща итератор към края.

* std::lower_bound е подобна - приема итератори към началото и края на range-a,
в който ще търси, както и елемент. Връща итератор към първия елемент от колекцията,
който е по-голям или равен на подадения. Ако няма такъв, връща итератор към края.
