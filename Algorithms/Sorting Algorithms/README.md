# Sorting Algorithms

## Бавни алгоритми

### Bubble Sort
Stable

### Selection Sort
Less swaps, but not stable

### Insertion Sort
Подходящ за малки масиви, и почти сортирани масиви. Това се дължи на ранното приключване на вътрешния цикъл при правилно поставено число (Best case сложността на алгоритъма е O(N)). Често се ползва в комбинация с други алгоритми.


## Бързи алгортми

### Merge Sort
Идея: Масивът се разделя на две половинки подмасиви. Всяка половинка продължава да се разделя. Процесът спира при достигане на масив с един елемент, който сам по-себе си е сортиран. Използваме индекси, понеже ако създаваме масиви за всяко извикване сложността откъм памет няма да бъде O(n)

### Quick Sort
Идея: Избира се елемент от масива, по-който ще се извършва подредбата. Чрез последователни промени, всички по-малки от избрания остават в лявата част на масива, а по-големите - в дясната. Избраният елемент се сменя с първия по-голям от него, за да се позиционира между двете групи.

### Counting Sort
Идея: Не използва директни сравнения. Заделя се масив с големина всички възможни стойности (K). Линейно се обхожда първоначалния масив и се броят срещанията на стойностите. Броят срещания се преобразуват в индекси, показващи до къде в сортирания масив ще достига всяка група-елементи. Чрез обхождане в обратна посока на оригиналния масив всеки елемент се поставя на съответния последен индекс за групата. Последният индекс за групата се намаля. Поставянето в сортиран ред се случва в нов масив. Накрая сортираните стойности от новия масив се презаписват в стария.

Counting sort, когато е възможно ползването му, позволява сортиране с линейна сложност.
